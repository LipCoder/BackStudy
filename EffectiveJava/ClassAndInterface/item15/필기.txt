item15. 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 차이점
==> 클래스 내부 데이터와 구현 정보를 외부로부터 얼마나 잘 숨겼느냐

내부 구현을 완벽히 숨겨 구현과 API를 깔끔하게 분리한다.

오직 API만을 사용하여 컴포넌트와 소통한다.
=> 정보 은닉(캡슐화)라고 하는 개념은 소프트웨어 설계의 근간이 되는 원리

* 정보 은닉의 장점
=> 컴포넌트를 서로 독립시켜 개발, 테스트, 최적화, 적용, 분석, 수정 등을 개별적으로 할 수 있게 해줌

1. 시스템 개발 속도를 높임. 여러 컴포넌트를 개별적으로 개발 할 수 있음
2. 시스템 관리 비용을 낮춤. 컴포넌트 교체가 비교적 쉬우며, 각 컴포넌트로 나뉘어져 있어 파악이 쉽다.
3. 정보 은닉 자체는 성능을 높여주지 않지만, 성능 최적화에 도움을 준다. 
   최적화할 컴포넌트를 정해 해당 컴포넌트만 최적화할 수 있기 때문이다. 
   => 최적화시 다른 컴포넌트에 영향을 주지 않음
4. 재사용성을 높힌다. 외부에 의존하지 않고 독자적으로 동작하는 컴포넌트라면
   낯선 환경에서도 유용하게 쓰일 가능성이 높음
5. 큰 시스템을 개발하는 난이도를 낮춰줌. 시스템이 완성되지 않아도 개별 컴포넌트의 동작을 확인할 수 있다.


* 정보 은닉의 핵심 
: 접근 제한자(private, protected, public)

* 기본 원칙
: * 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다. * (뭔뜻이고?)
   => 올바르게 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 함


클래스와 인터페이스에 부여할 수 있는 접근 수준
- package-private
- public

public으로 선언하면 공개 API가 됨
(API는 하위 호환을 위해 영원히 관리해줘야 함)
package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있음
(외부에서 쓸 이유가 없으면 package-private으로 선언하자)


public일 필요가 없는 클래스의 접근 수준을 package-private로 좁히자!

* 멤버에 부여할 수 있는 접근 수준
1. private : 멤버를 선언한 클래스에서만 접근 가능
2. package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
                     => 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준
3. protected : package-private의 접근 범위를 포함, 이 멤버를 선언한 클래스의
               하위 클래스에서도 접근할 수 있다.
4. public : 모든 곳에서 접근할 수 있음

클래스의 공개 API를 세심하게 설계(public)한 후, 그외 모든 것들은 private으로 만들자.
같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한해 package-private으로 풀어준다.
만약 권한을 푸는 일을 자주 하는 경우에는 컴포넌트를 더 분해해야 하는 것은 아닌지 고민해보자.
(private과 package-private은 공개 API에 영향을 주지 않음)

단 serializable(직렬화)을 구현한 클래스는 필드들이 의도치 않게 API가 공개 될수도 있다.

public 클래스의 접근 수준을 package-private에서 protected로 바꾸면 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다.
public 클래스의 protected 멤버는 공개 API이므로 영원히 지원돼야 한다. 내부 동작 방식을 API 문서에 적어 사용자에게 공개해야 할 수도 있다.
=> 따라서 protected 멤버 수는 적을수록 좋다.

클래스는 인터페이스가 정의하는 모든 메서드를 public으로 선언해야 한다.
=> 상위 클래스 메서드를 재정의할 때, 그 접근 수준을 상위 클래스보다 좁게 설정 할 수 없는 조건 때문에
    ==> 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 하는 규칙을 지키기 위해 필요
        (리스코프 치환 원칙)


코드를 테스트하기 위해서 클래스, 인터페이스, 멤버의 접근 범위를 넓히려고 할때 
=> 적당한 수준까지는 넓혀도 괜찮음 (private에서 package-private까지, 그러면 같은 패키지 상에 놓으면 접근이 가능하다) 
   ==> 하지만 이 이상은 안됨. 테스트만을 위해 공개 API로 만들어서는 안된다.


* public의 인스턴스 필드(인스턴스를 가지는 변수 등?)는 되도록 public이 아니여야 한다.
 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 
 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 뜻이다.
 또한 필드가 수정될 때 (락 획득 같은) 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로
 스레드 안전하지 않다. (not thread-safe) 

 
 이러한 문제는 정적 필드에서도 마찬가지이나, 예외가 하나 있다. 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 
 상수라면 public static final 필드로 공개해도 좋다. 이런 상수의 이름은 대문자로 쓰며, 각 단어 사이에 밑줄(_)을 넣는다.
 이런 필드는 반드시 기본 타입 값이나 불변 객체(Boolean, Integer, String 등이 대표적인 예)를 참조해야 한다.
 
 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다. 
 다른 객체를 참조하지는 못하지만, 참조된 객체 자체는 수정될 수 있으니 끔찍한 결과를 초래할 수도 있는 것이다.


길이가 0이 아닌 배열은 모두 변경이 가능하니 주의해야 한다. 클래스에서 public static final 배열 필드를 두거나
이 필드를 반환하는 접근자 메서드를 제공해서는 안된다. 이를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 된다.
다음 코드에는 보안 허점이 존재한다.

public static final Thing[] VALUEs = { ... };

해결책은 두가지이다. 
1. 앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가하는 것이다.

private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
 

2. 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법 (방어적 복사)

private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}

클라이언트 요구에 맞춰 둘 중 하나를 선택하면 된다. 
어느 반환 타입이 더 쓰기 편할지, 성능은 어느쪽이 나을지 고민해 정하자.


# 정리
프로그램 요소의 접근성을 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하라
그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.
public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. 
public static final 필드가 참조하는 개체가 불변인지 확인하라.

